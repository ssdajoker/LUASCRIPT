name: auto-merge-on-green

on:
  workflow_run:
    workflows: ["Parity and IR Gates", "Gemini PR Review Agent"]
    types: [completed]
  pull_request:
    types: [synchronize, opened, labeled]

permissions:
  contents: write
  pull-requests: write

jobs:
  enable-auto-merge:
    runs-on: ubuntu-latest
    if: |
      always() &&
      (github.event.pull_request == null || !github.event.pull_request.draft)
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find associated PR (from workflow_run)
        id: find_pr_workflow
        if: github.event_name == 'workflow_run'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const pr = (run.pull_requests || [])[0];
            if (pr) {
              core.setOutput('pr_number', pr.number);
            }

      - name: Get PR number (from pull_request event)
        id: get_pr
        if: github.event_name == 'pull_request'
        run: echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT

      - name: Determine PR number
        id: pr_num
        run: |
          PR=${{ steps.find_pr_workflow.outputs.pr_number || steps.get_pr.outputs.pr_number }}
          if [ -z "$PR" ]; then
            echo "Could not determine PR number"
            exit 0
          fi
          echo "number=$PR" >> $GITHUB_OUTPUT

      - name: Check PR and enable auto-merge
        if: steps.pr_num.outputs.number != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt('${{ steps.pr_num.outputs.number }}', 10);
            
            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            if (prData.state !== 'open') {
              core.info(`PR #${prNumber} is not open; skipping`);
              return;
            }
            
            if (prData.draft) {
              core.info(`PR #${prNumber} is draft; skipping`);
              return;
            }
            
            // Get latest commit status and check runs
            const { data: commitStatus } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: prData.head.sha,
            });
            
            const allChecksPass = commitStatus.state === 'success';
            
            // Get reviews
            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });
            
            const hasApproval = reviews.some((r) => r.state === 'APPROVED');
            
            if (!allChecksPass) {
              core.info(`Not all checks pass for PR #${prNumber} (status: ${commitStatus.state})`);
              return;
            }
            
            if (!hasApproval) {
              core.info(`PR #${prNumber} has no approvals; checking if we should skip this`);
              // Even without approval, if tests pass and it's labeled ready-for-review, auto-approve
              const hasReadyLabel = prData.labels.some(l => l.name === 'ready-for-review');
              if (hasReadyLabel) {
                // Approve on behalf of automation
                try {
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    event: 'APPROVE',
                    body: '✅ Automated approval: All tests passed and PR is ready for review.'
                  });
                  core.info(`Auto-approved PR #${prNumber}`);
                } catch (err) {
                  core.info(`Could not auto-approve: ${err.message}`);
                }
              }
            }
            
            // Enable auto-merge
            if (prData.auto_merge) {
              core.info(`Auto-merge already enabled for PR #${prNumber}`);
              return;
            }
            
            try {
              await github.graphql(
                `mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) {
                    pullRequest { number autoMergeRequest { enabledAt enabledBy { login } } }
                  }
                }`,
                {
                  pullRequestId: prData.node_id,
                  mergeMethod: 'SQUASH',
                }
              );
              core.info(`✅ Auto-merge ENABLED for PR #${prNumber}`);
            } catch (err) {
              const message = err && err.message ? err.message : String(err);
              core.warning(`Failed to enable auto-merge for PR #${prNumber}: ${message}`);
            }
